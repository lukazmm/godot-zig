import json

builtin_sizes = {}


def fill_builtin_sizes(api, build_config):
    """
    Fills the builtin sizes global dict
    """
    global builtin_sizes
    for size_list in api["builtin_class_sizes"]:
        if size_list["build_configuration"] == build_config:
            for size in size_list["sizes"]:
                builtin_sizes[size["name"]] = size["size"]
            break


def get_default_float_type():
    """
    The default type of a "float" if there is no meta
    """
    size = builtin_sizes["float"]
    if size == 8:
        return "f64"
    elif size == 4:
        return "f32"
    else:
        assert(False)


def get_default_int_type():
    """
    The default type of a "int" if there is no meta
    """
    size = builtin_sizes["int"]
    if size == 8:
        return "i64"
    elif size == 4:
        return "i32"
    else:
        assert(False)

# Double vs float only seems to affect vector types for now


def get_vector_float_type():
    """
    The type of float properties in the various vector classes.
    """
    vec2_size = builtin_sizes["Vector2"]
    vec3_size = builtin_sizes["Vector3"]
    vec4_size = builtin_sizes["Vector4"]

    if vec2_size == 8 and vec3_size == 12 and vec4_size == 16:
        return "f32"
    elif vec2_size == 16 and vec3_size == 24 and vec4_size == 32:
        return "f64"
    else:
        assert(False)


def get_vector_int_type():
    """
    The type of int properties in the various vector classes.
    """
    vec2i_size = builtin_sizes["Vector2i"]
    vec3i_size = builtin_sizes["Vector3i"]
    vec4i_size = builtin_sizes["Vector4i"]

    if vec2i_size == 8 and vec3i_size == 12 and vec4i_size == 16:
        return "i32"
    elif vec2i_size == 16 and vec3i_size == 24 and vec4i_size == 32:
        return "i64"
    else:
        assert(False)


def generate_bindings(api_filepath, bits="64", double="float", output_dir="."):
    api = None

    with open(api_filepath) as api_file:
        api = json.load(api_file)

    print("Builtin type config: " + double + "_" + bits)

    print("Filling lists...")
    fill_builtin_sizes(api, double + "_" + bits)

    print("Generating File...")

    result = []
    result += generate_header()
    result += generate_globals()
    result += genereate_constants(api)
    result += genereate_enums(api)
    result += genereate_builtins(api)
    result += genereate_classes(api)
    result += generate_utility(api)
    result += generate_footer()

    def addnewline(s): return s + "\n"

    contents = list(map(addnewline, result))

    with open("src/gen.zig", "w") as file:
        file.writelines(contents)


def generate_header():
    result = []
    result.append("// This file is automatically generated")
    result.append("const c = @import(\"c.zig\");")
    result.append("")
    return result


def generate_globals():
    result = []
    result.append("///////////////////")
    result.append("// Globals ////////")
    result.append("///////////////////")
    result.append("")
    result.append("var g_interface: ?c.GDNativeInterface = null;")
    result.append(
        "pub fn initInterface(interface: c.GDNativeInterface) void {")
    result.append("\tg_interface = interface;")
    result.append("\tinitUtilBindings();")
    result.append("}")
    result.append(
        "pub fn deinitInterface() void {")
    result.append("\tdeinitUtilBindings();")
    result.append("\tg_interface = null;")
    result.append("}")
    result.append(
        "fn get_interface() *const c.GDNativeInterface { return &(g_interface orelse unreachable); }")
    result.append("")
    float_t = get_vector_float_type()
    int_t = get_vector_int_type()
    result.append(f"pub const VecFloatT = {float_t};")
    result.append(f"pub const VecIntT = {int_t};")
    return result


def genereate_constants(api):
    result = []
    result.append("///////////////////")
    result.append("// Constants //////")
    result.append("///////////////////")
    result.append("")
    for constant in api["global_constants"]:
        name = constant["name"]
        value = constant["value"]
        result.append(
            f"const {name}: Int = {value};"
        )
    result.append("")
    return result


def genereate_enums(api):
    result = []
    result.append("///////////////////")
    result.append("// Enums //////////")
    result.append("///////////////////")
    result.append("")
    for enum in api["global_enums"]:
        name = enum["name"]
        if name.startswith("Variant."):
            continue
        result.append("pub const " + name + " = extern enum {")
        for value in enum["values"]:
            val_name = value["name"]
            val_value = value["value"]
            stripped_name = strip_enum_name(name, val_name).lower()
            result.append(f"\t{stripped_name} = {val_value},")
        result.append("};")
        result.append("")
    return result


def genereate_builtins(api):
    result = []

    result.append("///////////////////////")
    result.append("// Builtins ///////////")
    result.append("///////////////////////")
    result.append("")

    # Custom type implementations

    result.append(aabb_type)
    result.append(rect2_type)
    result.append(rect2i_type)
    result.append(vec2_type)
    result.append(vec2i_type)
    result.append(vec3_type)
    result.append(vec3i_type)
    result.append(vec4_type)
    result.append(vec4i_type)
    result.append(plane_type)
    result.append(transform2d_type)
    result.append(transform3d_type)
    result.append(projection_type)
    result.append(basis_type)
    result.append(quaternion_type)
    result.append(color_type)

    for builtin in api["builtin_classes"]:
        name = parse_type(builtin["name"])
        size = builtin_sizes[builtin["name"]]
        if is_custom_type(builtin["name"]):
            continue

        result.append("pub const " + name + " = extern struct {")
        result.append("\tinner: [" + str(size) + "]u8,")
        result.append("")

        has_destructor = "has_destructor" in builtin

        bindings = []

        if "constructors" in builtin:
            for constructor in builtin["constructors"]:
                index = constructor["index"]
                arguments = constructor["arguments"] if "arguments" in constructor else [
                ]
                constructor_name = builtin_constructor_name(name, index)

                bindings.append(
                    f"{constructor_name}: c.GDNativePtrConstructor")

                proto = make_function_proto(constructor_name, name, arguments)
                result.append("\tpub " + proto + " {")

                args = make_argument_array(arguments)
                result.append("\t\t" + args + ";")

                result.append("\t\tvar self = undefined;")
                result.append(
                    f"\t\t(get_bindings().{constructor_name})(&self, &args);")
                result.append("\t\treturn self;")
                result.append("\t}")

        if has_destructor:
            bindings.append(f"deinit: c.GDNativePtrDestructor")
            proto = make_function_proto("deinit", None, [], name, False)
            result.append("\tpub " + proto +
                          " { (get_bindings().deinit)(self); }")

        result.append("")

        if "methods" in builtin:
            for method in builtin["methods"]:
                method_name, return_type, arguments, is_const = parse_method(
                    method)

                bindings.append(
                    f"{method_name}: c.GDNativePtrBuiltInMethod")

                proto = make_function_proto(
                    method_name, return_type, arguments, name, is_const)
                result.append("\tpub " + proto + " {")

                args = make_argument_array(arguments)
                result.append("\t\t" + args + ";")

                arg_count = len(arguments)

                return_var = make_return(return_type)
                result.append("\t\t" + return_var + ";")
                result.append(
                    f"\t\t(get_bindings().{method_name})(self, &args, &_return, {arg_count});")

                if return_type != None:
                    result.append("\t\treturn _return;")

                result.append("\t}")

        result.append("")

        # Generating Bindings

        def addtabs(str):
            return "\t\t" + str

        result.append("\tconst Bindings = struct {")
        result.append(",\n".join(map(addtabs, bindings)))
        result.append("\t};")
        result.append("")
        result.append("\tvar g_bindings: ?Bindings = null;")
        result.append("\tpub fn initBindings() void {")
        result.append("\t\t const interface = get_interface();")
        result.append("\t\t g_bindings = .{")

        variant_type = convert_name_to_variant_type(name)

        if "constructors" in builtin:
            for constructor in builtin["constructors"]:
                index = constructor["index"]
                constructor_name = builtin_constructor_name(name, index)

                result.append(
                    f"\t\t\t.{constructor_name} = interface.variant_get_ptr_constructor(.{variant_type}, {index}),")

        if has_destructor:
            result.append(
                f"\t\t\t.deinit = interface.variant_get_ptr_destructor(.{variant_type}),")

        if "methods" in builtin:
            for method in builtin["methods"]:
                method_name = method["name"]
                method_hash = method["hash"]
                result.append(
                    f"\t\t\t.{method_name} = interface.variant_get_ptr_builtin_method(.{variant_type}, \"{method_name}\", {method_hash}),")

        result.append("\t\t};")

        result.append("\t}")
        result.append("\tpub fn deinitBindings() void { g_bindings = null; }")
        result.append(
            "\tfn get_bindings() *const Bindings { return &(g_bindings orelse unreachable); }")

        result.append("};")
        result.append("")
    return result


def genereate_classes(api):
    result = []

    result.append("///////////////////////")
    result.append("// Classes ////////////")
    result.append("///////////////////////")
    result.append("")

    for class_api in api["classes"]:
        name = parse_type(class_api["name"])
        result.append("pub const " + name + " = struct {")
        result.append("\tinner: c.GDNativeObjectPtr,")
        result.append("")

        if "enums" in class_api:
            for enum_api in class_api["enums"]:
                enum_name = enum_api["name"]
                result.append("\tpub const " + enum_name + " = extern enum {")
                for value in enum_api["values"]:
                    val_name = value["name"]
                    val_value = value["value"]
                    stripped_name = strip_enum_name(name, val_name).lower()
                    result.append(f"\t\t{stripped_name} = {val_value},")
                result.append("\t};")
                result.append("")

        # Generate Init function

        init_proto = make_function_proto("init", name, [])
        result.append("\tpub " + init_proto + " {")
        # Wrapped classes do not need an instance to be set
        result.append(
            f"\t\tconst object = get_interface().classdb_construct_object(\"{name}\");")
        result.append("\t\treturn .{ .inner = object };")
        result.append("\t}")
        result.append("")

        deinit_proto = make_function_proto("deinit", None, [], name, False)
        result.append("\tpub " + deinit_proto + " {")
        result.append(
            f"\t\tget_interface().object_destroy(self.inner);")
        result.append("\t}")
        result.append("")

        bindings = []

        if "methods" in class_api:
            for method in class_api["methods"]:
                if not "hash" in method:
                    continue

                method_name, return_type, arguments, is_const = parse_method(
                    method)

                binding_name = escape_identifier(method_name)
                bindings.append(f"{binding_name}: c.GDNativeMethodBindPtr")

                proto = make_function_proto(
                    method_name, return_type, arguments, name, is_const)
                result.append("\tpub " + proto + " {")

                args = make_argument_array(arguments)
                result.append("\t\t" + args + ";")

                arg_count = len(arguments)

                return_var = make_return(return_type)
                result.append("\t\t" + return_var + ";")

                error_var = make_error()
                result.append("\t\t" + error_var + ";")

                result.append(
                    f"\t\t(get_interface().object_method_bind_call)(get_binding().{binding_name}, self, &args, {arg_count}, &_return, &_error);")

                if return_type != None:
                    result.append("\t\treturn _return;")

                result.append("\t}")

         # Generating Bindings

        def addtabs(str):
            return "\t\t" + str

        result.append("\tconst Bindings = struct {")
        result.append(",\n".join(map(addtabs, bindings)))
        result.append("\t};")

        result.append("\tvar g_bindings: ?Bindings = null;")
        result.append("\tpub fn initBindings() void {")
        result.append("\t\tconst interface = get_interface();")
        result.append("\t\tg_bindings = .{")

        if "methods" in class_api:
            for method in class_api["methods"]:
                method_name = method["name"]
                binding_name = escape_identifier(method_name)
                if not "hash" in method:
                    continue
                method_hash = method["hash"]
                result.append(
                    f"\t\t\t.{binding_name} = interface.classdb_get_method_bind(\"{name}\", \"{method_name}\", {method_hash}),")

        result.append("\t\t};")

        result.append("\t}")

        result.append("\tpub fn deinitBindings() void { g_bindings = null; }")
        result.append(
            "\tfn get_bindings() *const Bindings { return &(g_bindings orelse unreachable); }")

        result.append("};")
        result.append("")

    return result


def generate_utility(api):
    result = []

    result.append("///////////////////////")
    result.append("// Utils //////////////")
    result.append("///////////////////////")
    result.append("")

    bindings = []
    for function in api["utility_functions"]:
        function_name, return_type, arguments = parse_function(function)

        bindings.append(f"{function_name}: c.GDNativePtrUtilityFunction")

        proto = make_function_proto(function_name, return_type, arguments)
        result.append("pub " + proto + " {")

        args = make_argument_array(arguments)
        result.append("\t" + args + ";")

        arg_count = len(arguments)

        return_var = make_return(return_type)
        result.append("\t\t" + return_var + ";")

        result.append(
            f"\t(get_util_bindings().{function_name})(&_return, &args, {arg_count});")

        if return_type != None:
            result.append("\treturn _return;")

        result.append("}")

    def addtab(s):
        return "\t" + s

    result.append("const UtilBindings = struct {")
    result.append(",\n".join(map(addtab, bindings)))
    result.append("};")

    result.append("var g_util_bindings: ?UtilBindings = null;")
    result.append("fn initUtilBindings() void {")
    result.append("\tconst interface = get_interface();")
    result.append("\tg_util_bindings = .{")

    for function in api["utility_functions"]:
        function_name = function["name"]
        function_hash = function["hash"]
        result.append(
            f"\t\t.{function_name} = interface.variant_get_ptr_utility_function(\"{function_name}\", {function_hash}),")

    result.append("\t};")
    result.append("}")

    result.append("fn deinitUtilBindings() void { g_util_bindings = null; }")
    result.append(
        "fn get_util_bindings() *UtilBindings { return &(g_util_bindings orelse unreachable); }")

    result.append("")
    return result


def generate_footer():
    result = []

    return result

###########################
## Utils ##################
###########################


def strip_enum_name(enum: str, member: str):
    return member


def make_function_proto(name, return_type, arguments, self=None, is_const=False):
    result = "fn "
    result += escape_identifier(to_camel_case(name))
    result += "("

    signature = []

    if self != None:
        self_type = parse_type(self)
        if is_const:
            signature.append(f"self: *const {self_type}")
        else:
            signature.append(f"self: *{self_type}")

    for index, par in enumerate(arguments):
        param_type = parse_type(
            par["type"], par["meta"] if "meta" in par else None)
        parameter_name = escape_identifier(par["name"])
        if len(parameter_name) == 0:
            parameter_name = "arg_" + str(index + 1)

        if param_pass_by_ptr(par["type"]):
            signature.append(f"{parameter_name}: *{param_type}")
        else:
            signature.append(f"{parameter_name}: {param_type}")

    result += ", ".join(signature)
    result += ") "

    if return_type == None:
        result += "void"
    else:
        result += parse_type(return_type)

    return result


def get_argument_names(arguments):
    result = []
    for index, par in enumerate(arguments):
        name = escape_identifier(par["name"])
        if len(name) == 0:
            name = "arg_" + str(index + 1)
        result.append(name)

    return result


def make_argument_array(arguments):
    arg_names = get_argument_names(arguments)
    if len(arg_names) == 0:
        return "const args: ?*anyopaque = null"
    else:
        arg_count = len(arg_names)

        def add_ampersand(s):
            return "&" + s

        args = ",".join(map(add_ampersand, arg_names))
        return f"const args: [{arg_count}]*anyopaque = ." + "{" + args + "}"


def make_return(return_type):
    if return_type == None:
        return "var _return: ?*anyopaque = null"
    else:
        name = parse_type(return_type)
        return f"var _return: {name} = undefined"


def make_error():
    return "var _error: c.GDNativeCallErrorType = undefined"


def parse_method(method):
    method_name = method["name"]

    return_type = None
    if "return_type" in method:
        return_type = parse_type(method["return_type"])
    if "return_value" in method:
        return_type = method["return_value"]["type"]
        return_meta = method["return_value"]["meta"] if "meta" in method["return_value"] else None
        return_type = parse_type(return_type, return_meta)

    arguments = method["arguments"] if "arguments" in method else []
    is_const = method["is_const"]
    return method_name, return_type, arguments, is_const


def parse_function(function):
    function_name = function["name"]

    return_type = None
    if "return_type" in function:
        return_type = parse_type(function["return_type"])
    if "return_value" in function:
        return_type = function["return_value"]["type"]
        return_meta = function["return_value"]["meta"] if "meta" in function["return_value"] else None
        return_type = parse_type(return_type, return_meta)

    arguments = function["arguments"] if "arguments" in function else []
    return function_name, return_type, arguments


def parse_type(name: str, meta=None):
    """
    Parses a type name. These are found in a variety of places in the extension_api.json, 
    including parameter types, return types, properties, and the names of classes and builtins.
    """
    # Strip prefixes
    name = name.replace("bitfield::", "")
    name = name.replace("enum::", "")

    if meta == None:
        def transform(name):
            if name == "void":
                return "anyopaque"
            elif name == "float":
                return get_default_float_type()
            elif name == "int":
                return get_default_int_type()
            elif name == "bool":
                return "bool"
            elif name == "Nil":
                return "Variant"
            else:
                return name

        is_const = False
        if name.startswith("const "):
            is_const = True
            name = name[6:]

        if name.endswith("**"):
            if is_const:
                return "**const " + transform(name[0:-2])
            else:
                return "**" + transform(name[0: -2])

        if name.endswith("*"):
            if is_const:
                return "*const " + transform(name[0:-1])
            else:
                return "*" + transform(name[0: -1])

        return transform(name)
    else:
        if name == "int":
            match meta:
                case "int8": return "i8"
                case "int16": return "i16"
                case "int32": return "i32"
                case "int64": return "i64"
                case "uint8": return "u8"
                case "uint16": return "u16"
                case "uint32": return "u32"
                case "uint64": return "u64"
                case other:
                    print(other)
                    raise AssertionError()
        elif name == "float":
            match meta:
                case "float": return "f32"
                case "double": return "f64"
                case other:
                    print(other)
                    raise AssertionError()
        else:
            raise AssertionError()


def param_pass_by_ptr(name):
    size = builtin_sizes[name] if name in builtin_sizes else None

    if size == None:
        return False
    if size != None:
        if size > 8:
            return True

    return False


def builtin_constructor_name(builtin, index):
    if builtin == "String":
        match index:
            case 0: return "default"
            case 1: return "copy"
            case 2: return "fromStringName"
            case 3: return "fromNodePath"
    elif builtin == "StringName":
        match index:
            case 0: return "default"
            case 1: return "copy"
            case 2: return "fromString"
    elif builtin == "RID":
        match index:
            case 0: return "default"
            case 1: return "copy"
    elif builtin == "Callable":
        match index:
            case 0: return "default"
            case 1: return "copy"
            case 2: return "init"
    elif builtin == "Signal":
        match index:
            case 0: return "default"
            case 1: return "copy"
            case 2: return "init"
    elif builtin == "Dictionary":
        match index:
            case 0: return "default"
            case 1: return "copy"
    elif builtin == "Array":
        match index:
            case 0: return "default"
            case 1: return "copy"
            case 2: return "fromByteArray"
            case 3: return "fromInt32Array"
            case 4: return "fromInt64Array"
            case 5: return "fromFloat32Array"
            case 6: return "fromFloat64Array"
            case 7: return "fromStringArray"
            case 8: return "fromVector2Array"
            case 9: return "fromVector3Array"
            case 10: return "fromColorArray"

    return "init" + str(index)


def convert_name_to_variant_type(name: str) -> str:
    match name:
        case "String": return "GDNATIVE_VARIANT_TYPE_STRING"
        case "StringName": return "GDNATIVE_VARIANT_TYPE_STRING_NAME"
        case "NodePath": return "GDNATIVE_VARIANT_TYPE_NODE_PATH"
        case "RID": return "GDNATIVE_VARIANT_TYPE_RID"
        case "Object": return "GDNATIVE_VARIANT_TYPE_OBJECT"
        case "Callable": return "GDNATIVE_VARIANT_TYPE_CALLABLE"
        case "Signal": return "GDNATIVE_VARIANT_TYPE_SIGNAL"
        case "Dictionary": return "GDNATIVE_VARIANT_TYPE_DICTIONARY"
        case "Array": return "GDNATIVE_VARIANT_TYPE_ARRAY"
        case "PackedByteArray": return "GDNATIVE_VARIANT_TYPE_PACKED_BYTE_ARRAY"
        case "PackedInt32Array": return "GDNATIVE_VARIANT_TYPE_PACKED_INT32_ARRAY"
        case "PackedInt64Array": return "GDNATIVE_VARIANT_TYPE_PACKED_INT64_ARRAY"
        case "PackedFloat32Array": return "GDNATIVE_VARIANT_TYPE_PACKED_FLOAT32_ARRAY"
        case "PackedFloat64Array": return "GDNATIVE_VARIANT_TYPE_PACKED_FLOAT64_ARRAY"
        case "PackedStringArray": return "GDNATIVE_VARIANT_TYPE_PACKED_STRING_ARRAY"
        case "PackedVector2Array": return "GDNATIVE_VARIANT_TYPE_PACKED_VECTOR2_ARRAY"
        case "PackedVector3Array": return "GDNATIVE_VARIANT_TYPE_PACKED_VECTOR3_ARRAY"
        case "PackedColorArray": return "GDNATIVE_VARIANT_TYPE_PACKED_COLOR_ARRAY"
        case other: return other

# Checks if type is a pod type


def is_custom_type(name):
    """
    Determines whether or not the type has a custom implementation.
    """
    return name in [
        "Nil",
        "bool",
        "float",
        "int",
        "Vector2",
        "Vector2i",
        "Rect2",
        "Rect2i",
        "Vector3",
        "Vector3i",
        "Transform2D",
        "Vector4",
        "Vector4i",
        "Transform3D",
        "Plane",
        "Quaternion",
        "AABB",
        "Basis",
        "Projection",
        "Color",
    ]


def escape_identifier(id):
    zig_keywords_map = {
        "type": "_type",
        "char": "_char",
        "bool": "_bool",
        "int": "_int",
        "case": "_case",
        "switch": "_switch",
        "export": "_export",
        "enum": "_enum",
        "struct": "_struct",
        "inline": "_inline",
        "align": "_align",
        "var": "_var",
        "error": "_error",
        "resume": "_resume",
        "async": "_async",
    }
    if id in zig_keywords_map:
        return zig_keywords_map[id]
    return id


def to_camel_case(snake_str: str):
    """
    Converts snake_str to camel case
    """
    components = snake_str.split('_')

    result = components[0]
    for x in components[1:]:
        if len(x) > 1:
            result += x[0].upper() + x[1:]
        else:
            result += x.upper()

    if len(result) > 1:
        return result[0].lower() + result[1:]
    else:
        return result.lower()

################################
## Custom Code #################
################################


aabb_type = """
pub const AABB = extern struct {
    position: Vector3,
    size: Vector3,
};
"""

rect2_type = """
pub const Rect2 = extern struct {
    position: Vector2,
    size: Vector2,
};
"""

rect2i_type = """
pub const Rect2i = extern struct {
    position: Vector2i,
    size: Vector2i,
};
"""

vec2_type = \
    """
pub const Vector2 = extern struct {
    x: T,
    y: T,

    pub const T = VecFloatT;

    pub const Axis = enum {
        axis_x,
        axis_y,
    };

    pub fn new(x: T, y: T) Vector2 {
        return .{.x = x, .y = y}
    }

    pub fn axis(self: *const Self, axis: Axis) *T {
        switch (axis) {
            .axis_x => return &self.x;
            .axis_y => return &self.y;
        }
    }

    pub fn plus(self: *const Self, other: *const Vector2) Vector2 {
        return Vector2.new(self.x + other.x, self.y + other.y);
    }

    pub fn plusAssign(self: *Self, other: *const Vector) void {
        self.x += other.x;
        self.y += other.y;
    }

    pub fn negative(self: *const Vector2) Vector2 {
        return Vector2.new(-self.x, -self.y)
    }
};
"""

vec2i_type = """
pub const Vector2i = extern struct {
    x: T,
    y: T,

    pub const T = VecIntT;
};
"""

vec3_type = """
pub const Vector3 = extern struct {
    x: T,
    y: T,
    z: T,

    pub const T = VecFloatT;
};
"""

vec3i_type = """
pub const Vector3i = extern struct {
    x: T,
    y: T,
    z: T,

    pub const T = VecIntT;
};
"""

vec4_type = """
pub const Vector4 = extern struct {
    x: T,
    y: T,
    z: T,
    w: T,

    pub const T = VecFloatT;
};
"""

vec4i_type = """
pub const Vector4i = extern struct {
    x: T,
    y: T,
    z: T,
    w: T,

    pub const T = VecIntT;
};
"""

transform2d_type = """
pub const Transform2D = extern struct { elements: [3]Vector2, };
"""

transform3d_type = """
pub const Transform3D = extern struct {
    basis: Basis,
    origin: Vector3,
};
"""

basis_type = """
pub const Basis = extern struct { 
    elements: [3]Vector3, 
};
"""

projection_type = """
pub const Projection = extern struct {
    matrix: [4]Vector4,
};
"""

plane_type = """
pub const Plane = extern struct {
    normal: Vector3,
    d: VecFloatT,
};
"""

quaternion_type = """
pub const Quaternion = extern struct {
    x: VecFloatT = 0.0,
    y: VecFloatT = 0.0,
    z: VecFloatT = 0.0,
    w: VecFloatT = 1.0,
};
"""

color_type = """
pub const Color = extern struct {
    r: VecFloatT,
    g: VecFloatT,
    b: VecFloatT,
    a: VecFloatT = 1.0,
};
"""


################################
## Actual code #################
################################

generate_bindings("godot-headers/extension_api.json")
